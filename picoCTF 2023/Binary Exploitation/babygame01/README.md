# babygame01

**100 points**

AUTHOR: PALASH OSWAL

Description
Get the flag and reach the exit.
Welcome to BabyGame! Navigate around the map and see what you can find! The game is available to download [here](https://github.com/LeonGurin/picoCTF-2023/blob/main/Binary%20Exploitation/babygame01/game). There is no source available, so you'll have to figure your way around the map. You can connect with it using nc saturn.picoctf.net 64790.

___

Damn I don't know how to describe this challenge, it was just something.

Bla bla the game is to get to a specific square in the game using `wasd` cool.

Let's look at the code itself using `IDA`.

```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  char v4; // [esp+1h] [ebp-AA5h]
  int v5[2]; // [esp+2h] [ebp-AA4h] BYREF
  char v6; // [esp+Ah] [ebp-A9Ch]
  char v7[2700]; // [esp+Eh] [ebp-A98h] BYREF
  unsigned int v8; // [esp+A9Ah] [ebp-Ch]
  int *p_argc; // [esp+A9Eh] [ebp-8h]

  p_argc = &argc;
  v8 = __readgsdword(0x14u);
  init_player(v5);
  init_map(v7, v5);
  print_map(v7, v5);
  signal(2, sigint_handler);
  do
  {
    do
    {
      v4 = getchar(p_argc);
      move_player(v5, v4, v7);
      print_map(v7, v5);
    }
    while ( v5[0] != 29 );
  }
  while ( v5[1] != 89 );
  puts("You win!");
  if ( v6 )
  {
    puts("flage");
    win();
    fflush(stdout);
  }
  return 0;
}
```

To #win we need to make `v6` not zero.

Because it was placed super well above the varible `v7` I tried for ages to perfom a buffer overflow using the `getchar()` function itself, dud.

The relevant piece of code to solve this is in the `move_player` function.

```c
_BYTE *__cdecl move_player(_DWORD *a1, char a2, int a3)
{
  _BYTE *result; // eax

  if ( a2 == 108 )
    player_tile = getchar();
  if ( a2 == 112 )
    solve_round(a3, a1);
  *(_BYTE *)(a1[1] + a3 + 90 * *a1) = 46;
  switch ( a2 )
  {
    case 'w':
      --*a1;
      break;
    case 's':
      ++*a1;
      break;
    case 'a':
      --a1[1];
      break;
    case 'd':
      ++a1[1];
      break;
  }
  result = (_BYTE *)(a1[1] + a3 + 90 * *a1);
  *result = player_tile;
  return result;
}
```

2 secret commands are now shown to us:

* `l` -> used to assign `player_tile` a value from `getchar()`

* `p` -> solve the game.

The trick is at the bottom of the function with these lines:

```c
result = (_BYTE *)(a1[1] + a3 + 90 * *a1);
*result = player_tile;
```

`result` is a pointer and the first line we give it the adderss to point to.

The second line we give it some value.

What if we could point result at `v6`? We can.

Because it is placed right above the variable `v7` in main, and that same variable is `a3` in this very equation, we can try to put a value inside the memory location:

```
v7 - offset = v6
```

We can do that by manipulating `*a1` and `a1[1]` because they are the variables we can change using `wasd`.

By manipulating such that `*a1 = -1` and `a1[1] = 86`

the equation will point to:

```
v7 - offset = v3 - 90*(-1) + 86 = v7 - 4
```

And if we put any value inside this location with the `l` option we will change the value of `v6`.

The input we will provide will be:

```
aaaaaaaawwww
l f
p
```

The first line places us at the coordinates (86, -1) and that's offscreen even.

*Note:* the value for `a[1]` which is controlled with `a` and `d` wraps around so if we are at 0,4 and press `a` we will end up at 3,89

Then when we assign this place in the memory the value of `f` (random non zero).

Then we "win" with `p`.

*Note:* we don't get the win message inside the `solve_round` because we don't meet its conditions to print "you win" because of our manipulation of the players position we did.

after all said and done, we exit the loops inside main and get the flag.

*The most confusing note:* why the hell is `v7 - 4` the address of `v6` and not `v7 - 1`?

I thought for the longest time that it must be `v7 - 1` because `v6` is a `char` varible, that takes one byte of memory and is off by one byte from `v7`.

My theory is that `IDA` did not decompile the type of `v6` correctly and its actually an `int` that takes 4 bytes, every attempt I had with `v7 - 1` to `v7 - 3` resulted in something unexpected. If my theory is correct it the value we assigned did bad things to `v7` itself.

In other decompilers I tried, it **IS** an int value.

*Conclusion:* this was a very hard challenge for me, definatly not 100 points as I see it.

> picoCTF{gamer_m0d3_enabled_3aa88304}
