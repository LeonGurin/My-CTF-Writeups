**crypto/tadpole**

*willwam*

tadpoles only know the alphabet up to b... how will they ever know what p is?


_Downloads_ [tadpole.py](https://github.com/LeonGurin/corCTF-2022/blob/main/tadpole/tadpole.py) [output.txt](https://github.com/LeonGurin/corCTF-2022/blob/main/tadpole/output.txt)
___

Looking at the code and reinterpreting it, we need to find `p`.

In order to do so we need to find the factors of 2 equations with our given knowledge:

* res1 = p * (numbers) = a*31337+b-f(31337)
* res2 = p * (other numbers) = a*f(31337)+b-f(f(31337))

With this python script I was able to know the solution `res1` and `res2`:

```python
from Crypto.Util.number import long_to_bytes

a =  7904681699700731398014734140051852539595806699214201704996640156917030632322659247608208994194840235514587046537148300460058962186080655943804500265088604049870276334033409850015651340974377752209566343260236095126079946537115705967909011471361527517536608234561184232228641232031445095605905800675590040729
b =  16276123569406561065481657801212560821090379741833362117064628294630146690975007397274564762071994252430611109538448562330994891595998956302505598671868738461167036849263008183930906881997588494441620076078667417828837239330797541019054284027314592321358909551790371565447129285494856611848340083448507929914
var1 =  52926479498929750044944450970022719277159248911867759992013481774911823190312079157541825423250020665153531167070545276398175787563829542933394906173782217836783565154742242903537987641141610732290449825336292689379131350316072955262065808081711030055841841406454441280215520187695501682433223390854051207100
var2 =  65547980822717919074991147621216627925232640728803041128894527143789172030203362875900831296779973655308791371486165705460914922484808659375299900737148358509883361622225046840011907835671004704947767016613458301891561318029714351016012481309583866288472491239769813776978841785764693181622804797533665463949

res1 = a*31337+b-var1
res2 = a*var1+b-var2
print(res1)
print()
print(res2)
```

Cool now what?

There is a little neat website that lets us cheat large number problems called [factordb.com](http://factordb.com/)

With its power we only need to find the largest devidor (that also happens to be prime) of the results.

Plugging `res1` into it gives us:

`3547 · 6982586976...21<308>`

this large number we can copy back and get the flag:

```python
var3 = 69825869768139920110123558205141272307543762521597238351171345853912801592499530806466923594706098233410739035037238284410149567840214740548173311389788461130930147434818011061522655481069898956513485105440304732927661965188218100508069264435861796272712210125342307926595478403514856023662724892152117159021
print(long_to_bytes(var3))
```

>corctf{1n_m4th3m4t1c5,_th3_3ucl1d14n_4lg0r1thm_1s_4n_3ff1c13nt_m3th0d_f0r_c0mput1ng_th3_GCD_0f_tw0_1nt3g3rs}

_Note:_ we could also do this with the res2 but I found out that the factors the website gives us are not actually factors, we are given that res2 is equal to:

` 5 · 8367339478...73<614>`

but this large number is not in the database so it can't factor it further to confirm the hypothesis though one of its devisors must be p.

And so I will call this unidetified number **Leon's number** look at all its glory!

83673394784955186247640007693702921561230764791927746255343482459066394844157743556559112367720019500824451137581701045984406796426935221820117899841380657621069641996849799129459208093348284787528423774597612754031532336131015073084393117971042780165148299066779333173676368309485564470859092877979201427874168642541155370697096305784815625341734699317964229155463468581223098662441582874251548905240403375840543778202602203133666368522157063421045499178618144325714996664298787202849612519312562512525336481800660411100911400047803067747683180813126522503656725095100526930340215508228066451792131277051091288373

